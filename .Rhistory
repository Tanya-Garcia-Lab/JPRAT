#cohort-pharos             0
#predict-pharos            0
## for bootstrap
boot.null.theta <- all_null_theta(theta.names,
study.names,
event.names=s.names,
z_lab_names,
x_lab_names,
label.dim.simus=boot,
label.name.simus=paste("boot",1:boot,sep=""),
time_val,param.label,
time_choice.predicted,time_choice.predicted.toadd,
la
)
num_time
boot.combi.null.theta <- all_null_theta(theta.names.combi,
study.names=combi.names,
event.names=s.names,
z_lab_names,
x_lab_names,
label.dim.simus=boot,
label.name.simus=paste("boot",1:boot,sep=""),
time_val,param.label,
time_choice.predicted,time_choice.predicted.toadd,
la
)
## estimation will be stored here: see while loop method=="gamm4"
## beta terms
betaest.store <- null.theta$null.theta.simus.est.ciboot$beta
## alpha terms
alphasest.store <- null.theta$null.theta.simus.est.ciboot$alpha
## Ft terms
Ftest.store <- null.theta$null.theta.simus.est.ciboot$Ft
if(num_study > 1){
## storage for comparing study differences
betabootci.store <- combi.null.theta$null.theta.simus.est.ci$beta   ## for beta
alphasbootci.store <- combi.null.theta$null.theta.simus.est.ci$alpha ## for alpha
Ftbootci.store <- combi.null.theta$null.theta.simus.est.ci$Ft  ## for Ft
} else {
betabootci.store <- NULL
alphasbootci.store <- NULL
Ftbootci.store <- NULL
}
## Ft predicted terms
Ftest.predicted.store <-  null.theta$null.theta.simus.est.ciboot$Ft.predicted  ## NULL
## NOT USED
alphasijest.store <- NULL
alphasijest.var.store <- NULL
alphasijbootci.store <- NULL
Ftijest.store <- NULL
Ftijest.var.store <- NULL
Ftijbootci.store <- NULL
## where to store number of event times <=t0
count.store <- NULL
count.store.outside <- NULL
#####################
## get true values ##
#####################
## sigmar may need EDITING if I change the way par2_fr,par_fu is formed.
truth <-get.truth(combi.study,combi.choice,
real_data,num_study,np,lb,num_time,
beta0int,beta0,gamma.param,omega.param,
time_val,time_choice.predicted,time_choice.predicted.toadd,
num_xx,a0,axmod,la,xks,zeval,z.choice,
sigmar=par2_fr[1],sigmau=par_fu["sd"],gtmod,use.random.effects,
null.theta,combi.null.theta)
## difference is 0?
betadiff.store <- truth$beta.diff
alphasdiff.store <- truth$alphas.diff
Ftdiff.store <- truth$Ft.diff
##############
## set seed ##
##############
set.seed(iseed)
print(paste("iseed=",iseed,sep=""))
if(num_study > 1){
## storage for comparing study differences
betabootci.store <- combi.null.theta$null.theta.simus.est.ci$beta   ## for beta
alphasbootci.store <- combi.null.theta$null.theta.simus.est.ci$alpha ## for alpha
Ftbootci.store <- combi.null.theta$null.theta.simus.est.ci$Ft  ## for Ft
} else {
betabootci.store <- NULL
alphasbootci.store <- NULL
Ftbootci.store <- NULL
}
## Ft predicted terms
Ftest.predicted.store <-  null.theta$null.theta.simus.est.ciboot$Ft.predicted  ## NULL
## NOT USED
alphasijest.store <- NULL
alphasijest.var.store <- NULL
alphasijbootci.store <- NULL
Ftijest.store <- NULL
Ftijest.var.store <- NULL
Ftijbootci.store <- NULL
## where to store number of event times <=t0
count.store <- NULL
count.store.outside <- NULL
num_time
#####################
## get true values ##
#####################
## sigmar may need EDITING if I change the way par2_fr,par_fu is formed.
truth <-get.truth(combi.study,combi.choice,
real_data,num_study,np,lb,num_time,
beta0int,beta0,gamma.param,omega.param,
time_val,time_choice.predicted,time_choice.predicted.toadd,
num_xx,a0,axmod,la,xks,zeval,z.choice,
sigmar=par2_fr[1],sigmau=par_fu["sd"],gtmod,use.random.effects,
null.theta,combi.null.theta)
## difference is 0?
betadiff.store <- truth$beta.diff
alphasdiff.store <- truth$alphas.diff
Ftdiff.store <- truth$Ft.diff
## make Ft monotonic
#' @import zoo
getF <- function(Ft,p){
n <- dim(Ft)[1]
F <- Ft
################################################
## Replace NA with last value carried forward ##
## - This assumes that Ft should be increasing from the lastest well-observe F(t) value
## - The assumption is similar to a Kaplan-Meier curve for the endpoints
F <- zoo::na.locf(F,na.rm=FALSE)  ## don't remove leading NA's.
if(any(is.na(Ft))){
## we don't run monotonicity
return(Ft)
} else {
for(i in 1:p){
#print(i)
tmp <- min(F[2:n,i]-F[1:(n-1),i])
k <- match(tmp,F[2:n,i]-F[1:(n-1),i]) #returns a vector of the position of first occurrence of the vector1 in vector2
while(tmp<0){
#print(tmp)
F[k,i]=(F[k+1,i]+F[k,i])/2
F[k+1,i]=F[k,i]
tmp <- min(F[2:n,i]-F[1:(n-1),i])
k <- match(tmp,(F[2:n,i]-F[1:(n-1),i]))
}
}
return(F)
}
}
#####################
## get true values ##
#####################
## sigmar may need EDITING if I change the way par2_fr,par_fu is formed.
truth <-get.truth(combi.study,combi.choice,
real_data,num_study,np,lb,num_time,
beta0int,beta0,gamma.param,omega.param,
time_val,time_choice.predicted,time_choice.predicted.toadd,
num_xx,a0,axmod,la,xks,zeval,z.choice,
sigmar=par2_fr[1],sigmau=par_fu["sd"],gtmod,use.random.effects,
null.theta,combi.null.theta)
## difference is 0?
betadiff.store <- truth$beta.diff
alphasdiff.store <- truth$alphas.diff
Ftdiff.store <- truth$Ft.diff
## function to produce true estimates (for simulation study)
#' @importFrom abind adrop
#' @import cubature
#' @import stats
get.truth <- function(combi.study,combi.choice,
real_data,num_study,np,lb,num_time,
beta0int,beta0,
gamma.param,  ## null
omega.param,  ## null
time_val,
time_choice.predicted, ## NULL
time_choice.predicted.toadd, ## NULL
num_xx,
a0, ## NULL
axmod, #"real" for all studies
la,
xks,
zeval, # k-means
z.choice, # 4
sigmar,sigmau, ## ??
gtmod, ## null
use.random.effects, ## null
null.theta,
combi.null.theta){
## storage for each estimate theta.names
beta.true <- null.theta$null.theta$beta  ## , , time = t100, theta = beta1
alphas.true <- null.theta$null.theta$alpha  ## , , xx = xx50, time = t100, theta = alpha1
Ft.true <- null.theta$null.theta$Ft  ## , , zz = D, xx = xx50, time = t100
Ft.predicted.true <- null.theta$null.theta$Ft.predicted  ## null
if(num_study > 1){
## study differences considered only if num_study > 1
beta.diff <- combi.null.theta$null.theta$beta
alphas.diff <- combi.null.theta$null.theta$alpha
Ft.diff <- combi.null.theta$null.theta$Ft
} else {
beta.diff <- NULL
alphas.diff <- NULL
Ft.diff <- NULL
}
if(real_data==FALSE){
## set up beta0,gamma, omega terms
for(tt in 1:num_time){
## for intercept term
if(!is.null(beta0int)){
beta.true[,,tt,"beta0"] <- beta.true.value(gtmod,beta0int,time_val[tt])  ## beta0int*gt(gtmod, time_val[[tt]]) where is this function from: main.R
}
## gamma_i term
if(!is.null(gamma.param)){
for(ii in 1:np){
beta.true[,ii,tt,"gamma"] <- beta.true.value(gtmod,gamma.param[ii],time_val[tt])
}
}
if(!is.null(omega.param)){
## omega_s term
for(ss in 1:num_study){
beta.true[ss,,tt,"omega"] <- beta.true.value(gtmod,omega.param[ss],time_val[tt])
}
}
}
## set up other terms
for(ss in 1:num_study){
for(ii in 1:np){
for(tt in 1:num_time){
## set up other beta terms
beta.index <- 1:lb[[ss]][[ii]]
beta.true[ss,ii,tt,paste("beta",beta.index,sep="")] <- beta.true.value(gtmod,
beta0[[ss]][[ii]],time_val[tt])
for(xx in 1:num_xx){
## set up alpha terms
alphas.true[ss,ii,xx,tt,] <- alpha.true(a0[[ss]][ii],
axmod[[ss]][ii],
xks[[ss]][xx],time_val[tt],gtmod)
## set up Ft terms
for(zz in 1:z.choice){
zeval.tmp <- as.matrix(zeval[ss,zz,ii,])
## z^T \beta
betaz.tmp <- beta.true[ss,ii,tt,paste("beta",beta.index,sep="")] %*% zeval.tmp
## \beta_0 + z^T\beta
if(!is.null(beta0int)){
betaz.tmp <- betaz.tmp + beta.true[1,1,tt,"beta0"] ## intercept
}
## gamma + \beta_0 +z^T\beta
if(!is.null(gamma.param)){
betaz.tmp <- betaz.tmp + beta.true[ss,ii,tt,"gamma"] ## gamma_i term
}
## omega + gamma + \beta_0 +z^T\beta
if(!is.null(omega.param)){
betaz.tmp <- betaz.tmp + beta.true[ss,ii,tt,"omega"] ## omega_s term
}
## integrate over random effects
if(use.random.effects==FALSE){ ## no random effects in model
Ft.true[ss,ii,zz,xx,tt] <- Ft.true.value(betaz=betaz.tmp,
alphastmp=alphas.true[ss,ii,xx,tt,la],
rval=0)
} else {  ## integrate over random effects
Ft.integrate <-
make.Ft.integrate(alphax=alphas.true[ss,ii,xx,tt,la],
betaz=betaz.tmp,sigmar,sigmau)
sigma_all <- c(sigmar,sigmau)
if(is.null(sigmau)){
Ft.true[ss,ii,zz,xx,tt] <-
integrate(Ft.integrate,-Inf,Inf)$value  # the final estimate of the integral.
} else {
Ft.true[ss,ii,zz,xx,tt] <-
adaptIntegrate(Ft.integrate,
lowerLimit=rep(-1,length(sigma_all)),
upperLimit=rep(1,length(sigma_all)))$integral  #  adaptive multidimensional integration of  vector-valued integrands over hypercubes: the value of the integral
}
}
}
}
}
}
}
}
## make Ft monotone
## applied to function of dimension time by p=xx
if(1==1){ ## for testing,  ### ulc: what this condition mean?
mono.Ftest <- apply.function.index(Ft.true,
dim.fun=c("time","xx"),getF,
p=length(dimnames(Ft.true)[["xx"]]))  ## monotone Function will get from getF
Ft.true <- mono.Ftest
} else {
mono.Ftest <- Ft.true
}
## end check for testing
## get predicted values: Pr(T<t|t>t0)
if(!is.null(time_choice.predicted)){
## extract Ft information
for(tt in 1:length(time_choice.predicted)){
for(tt0 in 1:length(time_choice.predicted.toadd)){
time.use <- paste("t",time_choice.predicted[tt]+
time_choice.predicted.toadd[tt0],sep="")
if(time.use %in% dimnames(mono.Ftest)$time){
Ft.predicted.true[,,,,tt,tt0] <-
(
abind::adrop(mono.Ftest[,,,,time.use,drop=FALSE],drop=c(5)) -
abind::adrop(mono.Ftest[,,,,paste("t",time_choice.predicted[tt],sep=""),drop=FALSE],
drop=c(5)))/
(1-abind::adrop(mono.Ftest[,,,,paste("t",time_choice.predicted[tt],sep=""),drop=FALSE],		drop=c(5)))
}
}
}
}
if(num_study > 1){
## check differences between studies
mydiff <- function(x){
x[combi.choice[1,]]-x[combi.choice[2,]]
}
## difference function to compare studies if num_study>1
beta.diff[1:combi.study,,,] <- apply.index(beta.true,"study",mydiff)
alphas.diff[1:combi.study,,,,] <- apply.index(alphas.true,"study",mydiff)
Ft.diff[1:combi.study,,,,] <-  apply.index(Ft.true,"study",mydiff)
}
alphas.true.mean <- apply.index(alphas.true,"time",mean,drop=FALSE)
list(beta.true=beta.true,
alphas.true=alphas.true,
alphas.true.mean=alphas.true.mean,
Ft.true=Ft.true,
Ft.predicted.true=Ft.predicted.true,
beta.diff=beta.diff,alphas.diff=alphas.diff,
Ft.diff=Ft.diff)
}
num_time
#####################
## get true values ##
#####################
## sigmar may need EDITING if I change the way par2_fr,par_fu is formed.
truth <-get.truth(combi.study,combi.choice,
real_data,num_study,np,lb,num_time,
beta0int,beta0,gamma.param,omega.param,
time_val,time_choice.predicted,time_choice.predicted.toadd,
num_xx,a0,axmod,la,xks,zeval,z.choice,
sigmar=par2_fr[1],sigmau=par_fu["sd"],gtmod,use.random.effects,
null.theta,combi.null.theta)
## difference is 0?
betadiff.store <- truth$beta.diff
alphasdiff.store <- truth$alphas.diff
Ftdiff.store <- truth$Ft.diff
##############
## set seed ##
##############
set.seed(iseed)
print(paste("iseed=",iseed,sep=""))
############################
## generate fixed effects ##
############################
fixed.effects <- generate.fixed.effects(num_study,
nmax,np,lb.max,n,lb,
fzrform,par1_fzr,par2_fzr,type_fzr,
fxform,par1_fx,par2_fx,type_fx,
real_data,
x_tmp.list,
z_tmp.list)
#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#++#+#+#+#+#++#+#+#+#+#+
#+
#+
#+               while Loop : main estimation and bootratp estimation
#+
#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#++#+#+#+#+#++#+#+#+#+#+
iters <-1
simus
##################################
## get data (simulated or real) ##
##################################
## keep x, z fixed in each simulation
## form s, delta, Y terms (uncensored (1) or not (0), not observed (999) ) : starting data
data <- simu.data.fixed.effects(
x=fixed.effects$x,
z=fixed.effects$z,
delta_tmp.list,
s_tmp.list, ## CAG repeat length?
a0,##null
axmod, ##"real"
num_time, ## 13
censorrate,## null
frform, ## null
type_fr, ## null
par1_fr,par2_fr,par1_fr2,par2_fr2,mix_n, par_fu, ## null
real_data,   ## true
time_val,    ## 40, 45, 50, ...100
beta0int, ## 0.5
beta0,
gamma.param,omega.param,## null
n, ## number of sample size
nmax,
m, ## observed event 0 or 1
maxm,
la,lb,
num_study,
np,
gtmod, ## null
use.random.effects, ## null
gen.cens.depend.z)	## null
num_time
#####################################
# no examples but add documentations#
#####################################
jprat.out<-jprat.main.estimates(method="gamm4",  ## conditional paramters to estimate using gamm4
compute.study.differences=FALSE, ## conditional parameter to do boostrap procedure
var.boot=TRUE, ## conditional parameter to do boostrap procedure
########################
# For main estimation function
########################
arbitrary, ## FALSE
num_study,np,
count.store, # null
count.store.outside, # null
data, #=data, ## data from simu.data.fixed.effects()
num_time, ## 13
time_val, ## specific time value 40, 45, ..., 90, 95, 100
time_choice.predicted, ## null
time_choice.predicted.toadd, ## null
n,nmax,m,maxm,
la,lb,
xks, ## 0, 0.1, ....0.7, ..., 0.9, 1
truth, #=truth, ## where do we define?
num_xx,  ## 18
knot.length, ## 8, where do we define?
real_data, ## TRUE
family.data, ## FALSE
zeval, ## at which points were estimated: k-means group
z.choice, ## 4
param.label, ## "beta0" "beta1"
beta0int, ## 0.5
gamma.param,omega.param, ## null
spline.constrain, ## TRUE
common.param.estimation, ## TRUE
est.cens.depend.z, ## FALSE
par_fu, ## null
analyze.separately, ## "event"
link.type, ## "logit"
null.theta, #=null.theta, ## why do we need it?
z.proportions=NULL, ## null
###########################
#For jprat estimation
###########################
betaest.store,
alphasest.store,
Ftest.store,
Ftest.predicted.store,
#combi.null.theta,
###########################
#For bootstraps estimation
###########################
combi.study,
combi.choice,
combi.names,
boot=boot,
boot.null.theta=boot.null.theta,
boot.combi.null.theta=boot.combi.null.theta, #=boot.combi.null.theta,
betabootci.store=betabootci.store,
alphasbootci.store=alphasbootci.store,
Ftbootci.store=Ftbootci.store,
#######################
# iteration
#######################
iters=iters
)
compute.study.differences=FALSE
var.boot=TRUE
z.proportions=NULL
num_time
#print(boot.null.theta);
#print(boot.combi.null.theta);
#################
## get Pr(Z=z) ##
#################
z.proportions <- z.proportions  ## NOT Implemented
method<-method;
iters<-iters;
method
num_time
gamm4.est <- gamm4.estimates(arbitrary, ## FALSE
num_study,np,
count.store, # null
count.store.outside, # null
data, #=data, ## data from simu.data.fixed.effects()
num_time, ## 13
time_val, ## specific time value 40, 45, ..., 90, 95, 100
time_choice.predicted, ## null
time_choice.predicted.toadd, ## null
n,nmax,m,maxm,
la,lb,
xks, ## 0, 0.1, ....0.7, ..., 0.9, 1
truth, ## where do we define?
num_xx,  ## 18
knot.length, ## 8, where do we define?
real_data, ## TRUE
family.data, ## FALSE
zeval, ## at which points were estimated: k-means group
z.choice, ## 4
param.label, ## "beta0" "beta1"
beta0int, ## 0.5
gamma.param,omega.param, ## null
spline.constrain, ## TRUE
common.param.estimation, ## TRUE
est.cens.depend.z, ## FALSE
par_fu, ## null
analyze.separately, ## "event"
link.type, ## "logit"
null.theta, ## why do we need it?
z.proportions=z.proportions)  ## estimation one run
library(knitr)
library(rmarkdown)
library(devtools)
library(roxygen2)
document()
build()
install()
check()
document()
build()
install()
check()
