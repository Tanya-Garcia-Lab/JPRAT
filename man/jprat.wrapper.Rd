% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jprat_function.R
\name{jprat.wrapper}
\alias{jprat.wrapper}
\title{JPRAT algorithm}
\usage{
jprat.wrapper(
  study.names,
  input.data.list,
  nonfunctional.covariate.names,
  functional.covariate.names,
  othercovariate.names,
  event.outcome.names,
  delta.names,
  time.points.for.prediction,
  time.points.for.conditional.prediction,
  time.points.for.conditional.prediction.toadd,
  nonfunctional.covariate.value,
  functional.covariate.values.of.interest,
  number.of.bootstraps,
  use.functional.beta.intercept,
  use.functional.event.coefficients,
  use.functional.study.coefficients,
  check.study.equality,
  estimated.parameters.common.for.all.studies,
  what.analyzed.separately,
  estimation.when.censoring.depends.on.z,
  use.bootstrap.variance,
  estimate.variances,
  write.output
)
}
\arguments{
\item{study.names}{A character vector of name of studies used in the analysis. e.g., c("cohort", "predict", "pharos").}

\item{input.data.list}{A list of datasets to be analyzed. In the case, you use datasets given from JPRAT, then there are two options:
use list(cohort=data_cohort, predict=data_predict, pharos=data_pharos) if you choose \code{what.analyzed.separately="event" or "eventstudy"};
otherwise use list(study1=simu_data1_model_A, study2=simu_data2_model_A) (See \code{what.analyzed.separately="none" or "study"} for option details).}

\item{nonfunctional.covariate.names}{A character vector for the name of the nonfunctional covariates that is used in the analysis.}

\item{functional.covariate.names}{A character vector for the name of the functional covariates that is used in the analysis.}

\item{othercovariate.names}{A character vector for the name of other covariates, which are not to be analyzed but kept within data during the analysis procedure.}

\item{event.outcome.names}{A character vector for the name of the time-to-event of interest (outcomes).}

\item{delta.names}{A character vector for the name of the censoring indicator for the time-to-event outcomes.}

\item{time.points.for.prediction}{A vector of time points at which the predicted values of marginal distribution will be estimated. Users may encounter a warning message that "Not enough data at time points (e.g., base_age);  May have divergent in the integration while bootstrapping." We recommend that users evaluate the proportional odds model at the average of nonfunctional covariate (e.g., base_age) across all subjects in each study. This may get rid of the warning messages.}

\item{time.points.for.conditional.prediction}{A vector of time points \eqn{t} at which the predicted values of conditional distribution \eqn{Pr(T <t + t_{0}| T>t)} will be estimated.}

\item{time.points.for.conditional.prediction.toadd}{A vector of future time points \eqn{t_{0}} at which the predicted values of conditional distribution \eqn{Pr(T <t + t_{0} | T>t)} will be estimated.}

\item{nonfunctional.covariate.value}{A numeric value interested for the nonfunctional covariate. e.g., 40 for \code{base_age}, which will be used for prediction.}

\item{functional.covariate.values.of.interest}{A vector of specific functional covariate values \eqn{X=x} where the smooth functional parameter \eqn{\alpha(X=x,t)} will be estimated. For example, we set \eqn{x=46,48,50} in the analysis. We recommend that the specific functional covariate values \eqn{X=x} should be chosen between the minimum and the maximum of functional covariate values. Otherwise, users may encounter a warning message.}

\item{number.of.bootstraps}{The number of bootstrap iterations. The bootstrap procedure is to do a hypothesis testing, which compares functional parameters over interested time points among studies.}

\item{use.functional.beta.intercept}{A logical value whether a functional intercept \eqn{\beta_{0}(t)} is included in the time-varying proportional odds model. The default option is TRUE.}

\item{use.functional.event.coefficients}{A logical value whether the event specific effect \eqn{\gamma_{e}(t)} will be used in the time-varying proportional odds model. The default option is TRUE.}

\item{use.functional.study.coefficients}{A logical value whether the study specific effect \eqn{\omega_{s}(t)} will be used in the time-varying proportional odds model. The default option is TRUE.}

\item{check.study.equality}{A logical value whether estimates are similar across studies: The default option is TRUE when what.analyzed.separately is "none"; otherwise, FALSE.}

\item{estimated.parameters.common.for.all.studies}{A logical value whether the model parameters are same across studies. The default option is FALSE.}

\item{what.analyzed.separately}{A character value to determine whether the event information from all studies is analyzed jointly or separately with distinct or shared study parameters in the model: the options are "studyevent" (studies and event), "study", "event", or "none".}

\item{estimation.when.censoring.depends.on.z}{A logical value whether the estimation process assumes that a censoring distribution depends on nonfunctional covariates \eqn{Z}. If covariates \eqn{Z} does not follow a binomial distribution, then the default option is FALSE.}

\item{use.bootstrap.variance}{A logical value whether the bootstrap variances will be evaluated. The default option is TRUE.}

\item{estimate.variances}{A logical value how variances will be estimated. If this is TRUE, there are two options: "est" (estimated), and "quant" (quantiles from bootstrap).
If this is FALSE, the only option is  "none" (no variances are estimated). The default option is "est".}

\item{write.output}{A logical value whether outputs should be saved into data files. The default option is TRUE.}
}
\value{
A list of
         \item{jprat.output}{A list of estimated values. If write.output=TRUE, the list contains simulation results as data.theta and combi.out;
         \itemize{
         \item theta.out: a data frame of the estimated values for all components ("beta0", "beta1",  "alphas", "Ft", "Ft.predicted")
         at each iteration for the clinical events of interest per study. The columns of the data frame include iteration number (iters), the name of studies (study), the names of outcomes (event), the names for all components to be estimated (theta), the labels of the nonfunctional covariates Z (zz)),
         the labels of the functional covariates X (xx), all estimated values for theta: "est", "varest", "varlo", "varhi", "boot_varest", "boot_varlo", "boot_varhi" (val)
         and the time points.
         \item combi.out: a data frame of the difference of the estimated values between a pair of studies for all components ("beta0", "beta1", "alphas", "Ft", "Ft.predicted")
         at each iteration for the clinical events of interest per a pair of studies.
         The columns of the data frame include the number of iteration (iters), the names for the combinations of studies (study): cohort-predict, cohort-pharos, predict-pharos),
         the names of outcome events (event), the names for all components to be estimated (theta), the labels of the nonfunctional covariates Z (zz), the labels of the functional covariates X (xx),
         all estimated values for theta: "est", "varest", "varlo", "varhi", "boot_varest", "boot_varlo","boot_varhi" (val) and the time points.}
         If write.output=FALSE, jprat.output returns a list whose elements contain the estimated values for \eqn{beta(t)}, \eqn{alpha(X,t)}, \eqn{Ft(t)} and \eqn{F_{es}(t|X, Z)} for each study (see \code{null.theta.simus.est.ciboot} for the array from)
          and for a pair of studies for comparison (see \code{null.theta.simus.est.ci} for the array form).}
         \item{eflag}{an integer number to check if any error comes up while estimation algorithm is processed.
                      If this value is -1, then the marginal distribution \eqn{F_{es}(t|X, Z)} has missing values (NA).}
}
\description{
This function calls JPRAT algorithm and runs it.
}
\details{
The Joint Progression of Risk Assessment Tool (JPRAT) evaluates and compares all outcomes simultaneously
         across multiple studies and adjusts for outcome dependencies.
         The function \code{\link{jprat.wrapper}} is an estimation procedure that handles multiple data hierarchy
         using an additive logistic mixed effect model. The algorithm handles censoring with pseudo-values and
         functional covariate effects with splines.
         There are four options whether the event information from all studies is analyzed jointly or separately with distinct or shared study parameters in the model.
         If you choose
         \itemize{
         \item \code{what.analyzed.separately}="study", then JPRAT assumes separate study models, i.e., event information from each study is analyzed separately.
         \item \code{what.analyzed.separately}="event", then JPRAT analyzes the events separately and uses common parameters across all events.
         \item \code{what.analyzed.separately}="none",  then JPRAT does not analyze the data separately.
         \item \code{what.analyzed.separately}="studyevent", then JPRAT analyzes the evnts and sutdies separately.
}
}
\examples{
library(JPRAT)

## Choose option whether study and event are analyzed separately:
## Four options are available for what.analyzed.separately="studyevent", "event", "study" or "none"

     what.analyzed.separately= "none"


## Load your data in the list format: should match order of study.names
## Choose different datasets depending on your choice for what.analyzed.separately:

    if(what.analyzed.separately=="event"||what.analyzed.separately=="studyevent"){

       input.data.list=list(cohort=data_cohort, predict=data_predict, pharos=data_pharos);

    }else if(what.analyzed.separately=="none"||what.analyzed.separately=="study"){

       input.data.list=list(study1=simu_data1_model_A, study2=simu_data2_model_A);
    }




####################################################################
## Input data for JPRAT estimation procedure: parameter settings  ##
####################################################################

    if(what.analyzed.separately=="event"||what.analyzed.separately=="studyevent"){


      study.names=c("cohort", "predict", "pharos");
      othercovariate.names=c("firstyear", "lastyear");
      event.outcome.names=c("hdage_nobase", "mcione", "dep2");
      delta.names=c("delta.hdage_nobase", "delta.mcione", "delta.dep2");
      nonfunctional.covariate.names=c("base_age");
      functional.covariate.names="CAG";
      time.points.for.prediction=seq(46, 66, by=5);
      time.points.for.conditional.prediction=c(46,51, 56);
      time.points.for.conditional.prediction.toadd=c(5);
      nonfunctional.covariate.value=c(40);
      functional.covariate.values.of.interest=c(46, 48, 50) ;

    }else if(what.analyzed.separately== "none"||what.analyzed.separately=="study"){

      study.names=c("study1", "study2");
      othercovariate.names=NULL;
      event.outcome.names=c("event1", "event2");
      delta.names=c("delta.event1", "delta.event2");
      nonfunctional.covariate.names=c("base_age");
      functional.covariate.names="CAG";
      time.points.for.prediction=  c(seq(40,60,by=1));
      time.points.for.conditional.prediction=c(40, 55);
      time.points.for.conditional.prediction.toadd=c(5,10);
      nonfunctional.covariate.value=c(42);
      functional.covariate.values.of.interest=c(42);

    }


    if(what.analyzed.separately!="none"){
      check.study.equality=FALSE
      estimated.parameters.common.for.all.studies=FALSE
    }else{
      check.study.equality=TRUE
      estimated.parameters.common.for.all.studies=TRUE
    }

    number.of.bootstraps=10;
    use.functional.beta.intercept= TRUE ;
    use.functional.event.coefficients= TRUE;
    use.functional.study.coefficients=TRUE;
    use.bootstrap.variance=TRUE;
    estimation.when.censoring.depends.on.z=FALSE ;
    estimate.variances="est"
    write.output=TRUE;

#############################################
## a function to estimate JPRAT algorithm  ##
#############################################

  jprat.estimat.results<-jprat.wrapper(study.names=study.names,
                                       input.data.list=input.data.list,
   nonfunctional.covariate.names=nonfunctional.covariate.names,
   functional.covariate.names=functional.covariate.names,
   othercovariate.names=othercovariate.names,
   event.outcome.names=event.outcome.names,
   delta.names=delta.names,
   time.points.for.prediction=time.points.for.prediction,
   time.points.for.conditional.prediction=time.points.for.conditional.prediction,
   time.points.for.conditional.prediction.toadd=time.points.for.conditional.prediction.toadd,
   nonfunctional.covariate.value=nonfunctional.covariate.value,
   functional.covariate.values.of.interest=functional.covariate.values.of.interest,
   number.of.bootstraps=number.of.bootstraps,
   use.functional.beta.intercept=use.functional.beta.intercept,
   use.functional.event.coefficients=use.functional.event.coefficients,
   use.functional.study.coefficients=use.functional.study.coefficients,
   check.study.equality=check.study.equality,
   estimated.parameters.common.for.all.studies=estimated.parameters.common.for.all.studies,
   what.analyzed.separately=what.analyzed.separately,
   estimation.when.censoring.depends.on.z=estimation.when.censoring.depends.on.z,
   use.bootstrap.variance=use.bootstrap.variance,
   estimate.variances=estimate.variances,
   write.output=write.output)

##########################################################
## Get a table for the number of people who are at risk ##
##########################################################

    if(what.analyzed.separately=="event"||what.analyzed.separately=="studyevent"){

      study.names=c("cohort", "predict", "pharos");
      event.outcome.names=c("hdage_nobase", "mcione", "dep2");
      nonfunctional.covariate.names=c("base_age");
      functional.covariate.names="CAG";

    }else if(what.analyzed.separately=="none"||what.analyzed.separately=="study"){

      study.names=c("study1", "study2");
      othercovariate.names=NULL;
      event.outcome.names=c("event1", "event2");
      delta.names=c("delta.event1", "delta.event2");
      nonfunctional.covariate.names=c("base_age");
      functional.covariate.names="CAG";

    }



    if(what.analyzed.separately=="event"||what.analyzed.separately=="studyevent"){

      time.points.for.prediction=seq(46, 66, by=5);
      functional.covariate.values.of.interest=c(46, 48, 50) ;
      nonfunctional.covariate.value=c(40);

    }else if(what.analyzed.separately=="none"||what.analyzed.separately=="study"){

      time.points.for.prediction=  c(seq(40,60,by=1))
      functional.covariate.values.of.interest=c(42);
      nonfunctional.covariate.value=c(42);

    }

    if(what.analyzed.separately!="none"){
      estimated.parameters.common.for.all.studies=FALSE
    }else{
      estimated.parameters.common.for.all.studies=TRUE
    }

###############################################################################
## a function to create a table for the number of patients who are at risk   ##
###############################################################################

    number.at.risk <- compute.number.at.risk.for.HD(study.names,
     input.data.list,
     event.outcome.names,
     nonfunctional.covariate.names,
     functional.covariate.names,
     nonfunctional.covariate.value,
     functional.covariate.values.of.interest,
     time.points.for.prediction,
     estimated.parameters.common.for.all.studies,
     write.output=TRUE
     )




##############################
## parameters to get results #
##############################

    if(what.analyzed.separately=="event"||what.analyzed.separately=="studyevent"){

      functional.covariate.values.of.interest.ci=c(46, 51);
      time.points.of.interest= c(46, 56);
      time.points.of.interest.ci=seq(46, 66, by=5);
      functional.covariate.comparisons=c(46, 51);
      time.points.for.prediction=seq(46, 66, by=5);
      functional.covariate.values.of.interest=c(46, 48, 50) ;
      nonfunctional.covariate.value=c(40);
      color.names=c("firebrick1", "darkgreen", "black");
      legend.names=c("Motor Diagnosis (DCL=4)");


    }else{

      functional.covariate.values.of.interest.ci=c(40, 55);
      time.points.of.interest= c(40, 55);
      time.points.of.interest.ci=seq(40, 60, by=5);# c(seq(40,60,by=1))
      functional.covariate.comparisons=c(40, 55);
      time.points.for.prediction=  c(seq(40,60,by=1))
      functional.covariate.values.of.interest=c(42);
      nonfunctional.covariate.value=c(42);
      color.names=c("firebrick1", "darkgreen");
      legend.names=c("event1", "event2");

    }


    do.plots=TRUE;
    plot.confidence.intervals=TRUE;
    add.number.at.risk.legend=TRUE;
    ylabel.for.plots.comparing.studies="Probability"
    xlabel.for.plots.comparing.studies="Age (years)"
    file.name.for.analysis="test" ## figure names
    show.results.description=TRUE;


## is.nrisk.data.frame=TRUE when users choose write.output=TRUE
## and output for nrisk returns as the form of dataframe.
## is.nrisk.data.frame=FALSE when users choose write.output=FALSE
## and output for nrisk returns as an array form.
## users need to choose write.jprat.output=TRUE in jprat.wrapper function;
## FALSE otherwise.


    if(write.output==TRUE){

    is.nrisk.data.frame=TRUE;
    write.jprat.output=TRUE;

    }else{
      is.nrisk.data.frame=FALSE;
      write.jprat.output=FALSE;
    }


####################################
## functions to get default values #
####################################

    if(what.analyzed.separately=="studyevent"){


      study.names=c("cohort", "predict", "pharos");
      event.outcome.names=c("hdage_nobase", "mcione", "dep2");
      legend.names=c("Motor Diagnosis (DCL=4)")


    }else if(what.analyzed.separately=="event"){

      study.names=c("cohort", "predict", "pharos");
      event.outcome.names=c("hdage_nobase", "mcione", "dep2");
      legend.names=c("Motor Diagnosis (DCL=4)", "Cognitive Impairment", "Stage II TFC")

    }else if(what.analyzed.separately=="none"||what.analyzed.separately=="study"){

      color.names=c("firebrick1", "darkgreen"); ## for color.label.key
      event.outcome.names=c("event1", "event2")
      legend.names=c("Motor Diagnosis (DCL=4)", "Cognitive Impairment");

    }


    ## allocate jprat outputs
    jprat.output<-jprat.estimat.results$jprat.output
    nrisk<-number.at.risk


##################################################################
## a function to display all results including tables and plots ##
##################################################################

    results.out <- view.all.results(
      ############################
      # arguments for JPRAT     ##
      ############################
      study.names,
      #data.file.names,
      input.data.list,
      nonfunctional.covariate.names,
      functional.covariate.names,
      othercovariate.names,
      event.outcome.names,
      delta.names,
      time.points.for.prediction,
      time.points.for.conditional.prediction,
      time.points.for.conditional.prediction.toadd,
      nonfunctional.covariate.value,
      functional.covariate.values.of.interest,
      #############################
      ## Input: How to analysis  ##
      #############################
      number.of.bootstraps, #=100,
      use.functional.beta.intercept,
      use.functional.event.coefficients,
      use.functional.study.coefficients,
      check.study.equality,
      estimated.parameters.common.for.all.studies,
      what.analyzed.separately,
      estimation.when.censoring.depends.on.z,
      use.bootstrap.variance,
      ##########################
      ## For plotting results ##
      ##########################
      functional.covariate.values.of.interest.ci,
      time.points.of.interest,
      time.points.of.interest.ci,
      label.for.alpha.values.over.time=NULL,
      color.names=color.names, ## returns color.labels
      legend.names=legend.names, ## returns legend.labels
      functional.covariate.comparisons=functional.covariate.comparisons,
      functional.covariate.comparisons.for.sample.size=NULL,
      #############################
      # plot options             ##
      #############################
      do.plots=do.plots,
      plot.confidence.intervals=plot.confidence.intervals,
      ###########################
      # Label figures or files ##
      ###########################
      add.number.at.risk.legend=add.number.at.risk.legend,
      ylabel.for.plots.comparing.studies=ylabel.for.plots.comparing.studies,
      xlabel.for.plots.comparing.studies=xlabel.for.plots.comparing.studies,
      file.name.for.analysis=file.name.for.analysis, ## figure names
      #######################
      ## Output from JPRAT ##
      #######################
      jprat.output=jprat.output,
      nrisk=nrisk,
      #####################################
      ## Do we show results description? ##
      #####################################
      show.results.description=show.results.description,
      is.nrisk.data.frame=is.nrisk.data.frame,
      write.jprat.output=write.jprat.output
    )


}
\references{
To see the detailed description for the JPRAT estimation procedure, we refer to
         \itemize{
         \item Garcia, T. P., Marder, K., Wang, Y. (2017). Time-varying proportional odds model for mega-analysis of clustered event
         times. Biostatistics, 20(1), 129-146.
         }
         To see the detailed real data analysis, we refer to
         \itemize{
         \item Garcia, T.P., Wang, Y., Shoulson, I., Paulsen, J.S. and Marder, K. (2018). Disease progression in Huntington disease:
         An analysis of multiple longitudinal outcomes. Journal of Huntington's disease, 7, 337-344}
}
