% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jprat_function.R
\name{jprat.wrapper}
\alias{jprat.wrapper}
\title{This function is to call and run JPRAT algorithm.}
\usage{
jprat.wrapper(
  study.names,
  input.data.list,
  nonfunctional.covariate.names,
  functional.covariate.names,
  othercovariate.names,
  event.outcome.names,
  delta.names,
  time.points.for.prediction,
  time.points.for.conditional.prediction,
  time.points.for.conditional.prediction.toadd,
  nonfunctional.covariate.value,
  functional.covariate.values.of.interest,
  number.of.bootstraps,
  use.functional.beta.intercept,
  use.functional.event.coefficients,
  use.functional.study.coefficients,
  check.study.equality,
  estimated.parameters.common.for.all.studies,
  what.analyzed.separately,
  estimation.when.censoring.depends.on.z,
  use.bootstrap.variance,
  estimate.variances,
  write.output
)
}
\arguments{
\item{study.names}{a character vector of name of studies used in analyses. e.g., c("cohort", "predict", "pharos").}

\item{input.data.list}{a list of data sets to be analyzed. If you want to use data sets provided by JPRAT,
use list(cohort=data_cohort, predict=data_predict, pharos=data_pharos), otherwise you need to feed your own data files list(study.name1=data.set1, study.name2=data.set2, study.name3=data.set3). The order of data sets should match study.names.}

\item{nonfunctional.covariate.names}{a character vector for the name of the non-functional covariates that is used in the analysis.  e.g., "base_age".}

\item{functional.covariate.names}{a character vector for the name of the functional covariates that is used in the analysis.
e.g., \code{"CAG"}.}

\item{othercovariate.names}{a character vector for the name of other covariates not to be analyzed but kept within the data used in the analysis: the first year when subjects visit clinics  and the last year when subjects stop visiting clinics. e.g.,  c("firstyear", "lastyear").}

\item{event.outcome.names}{a character vector for the name of the time-to-event outcomes interested: For example, the HD age onsets, first cognitive impairments,and stage II total function capacity. e.g., c("hdage_nobase", "mcione", "tfctwo").}

\item{delta.names}{a character vector for the name of the censoring indicator for time-to-event outcomes.}

\item{time.points.for.prediction}{a vector of time points at which the predicted values of marginal distribution will be estimated. e.g., time points are at 46, 51, 56, 61, and 66.
Users may encounter a warning message that "Not enough data at time points (e.g., base_age);  May have divergent in the integration while bootstrapping." We recommend that users evaluate the proportional odds model at the average of nonfunctional covariate (e.g., base_age) across all subjects in each study.
This may get rid of the warning messages.}

\item{time.points.for.conditional.prediction}{a vector of time points \eqn{t} at which the predicted values of conditional distribution \deqn{Pr(T <t + t_0| T>t)} will be estimated. e.g., time points \eqn{t} are at \eqn{t=46, 51, 56}.}

\item{time.points.for.conditional.prediction.toadd}{a vector of future time points \eqn{t_0} at which the predicted values of conditional distribution \deqn{Pr(T <t + t_0 | T>t)} will be estimated. e.g., time points are at \eqn{t_0=5}.}

\item{nonfunctional.covariate.value}{a numeric value interested for the nonfunctional covariate. e.g., 40 for \code{base_age}, which will be used for prediction.}

\item{functional.covariate.values.of.interest}{a vector of specific functional covariate values \eqn{X=x} where the smooth functional parameter \eqn{\alpha(X=x,t)} will be estimated. For example, we set \eqn{x=46,48,50} in the analysis. We recommend that the specific functional covariate values \eqn{X=x} should be chosen between the minimum and the maximum of functional covariate values. Otherwise, users may encounter a warning message.}

\item{number.of.bootstraps}{number of bootstrap iterations. The bootstrap procedure is to do hypothesis testing, which compares functional parameters over interested time points among studies.  e.g., 100.}

\item{use.functional.beta.intercept}{a logical value whether a functional intercept (coefficient) of \eqn{\beta_0(t)} is included in the  time-varying proportional odds model. Default is TRUE.}

\item{use.functional.event.coefficients}{a logical value whether the event specific effect \eqn{\gamma_e(t)} will be used in the  time-varying proportional odds model. Default is TRUE.}

\item{use.functional.study.coefficients}{a logical value whether the study-specific effect \eqn{\omega_s(t)} will be used in the time-varying proportional odds model. Default is TRUE.}

\item{check.study.equality}{a logical value whether estimates are similar across studies: Default is FALSE. Set TRUE when what.analyzed.separately is "none".}

\item{estimated.parameters.common.for.all.studies}{a logical value whether the model parameters are the same across studies. Default is FALSE.}

\item{what.analyzed.separately}{a character value to determine whether analysis will be performed separately or jointly: the options are "studyevents" (studies and event), "studies", "events", or "none". Default is "studyevents".}

\item{estimation.when.censoring.depends.on.z}{a logical value whether the estimation process assumes that a censoring distribution depends on nonfunctional covariates Z. If covariates Z does not follow a binomial distribution, then default is FALSE.}

\item{use.bootstrap.variance}{a logical value whether to compute bootstrap variances. Default is TRUE.}

\item{estimate.variances}{a logical value how variances will be estimated. If this is TRUE, there are two options: "est" (estimated), and "quant" (quantiles from bootstrap);
If this is FALSE, the only option is  "none" (no variances are estimated). Default is ``est".}

\item{write.output}{a logical value whether outputs will be saved into data files. Default is TRUE.}
}
\value{
A list of
         \item{theta.out}{data frame of the estimated values for all components ("beta0", "beta1",  "alpha1", "Ft", "Ft.predicted")
                          at each iteration for the clinical events of interest per study. The columns of the data frame include iters (iteration number), study(names of studies), event (the names of outcome events), theta (names for all components to be estimated), zz (the labels of the nonfunctional covariates Z),
                          xx (the labels of the functional covariates X), val (all estimated values for theta: "est”, "varest”, "varlo”, "varhi”, "boot_varest”, "boot_varlo”, "boot_varhi”)
                          and the flatten time points.}
         \item{combi.out}{a data frame of the difference of the estimated values between a pair of studies for all components ("beta0", "beta1", "alpha1", "Ft", "Ft.predicted")
                          at each iteration for the clinical events of interest per a pair of studies.
                          The columns of the data frame include iters (iteration number), study(names for the combinations of studies: cohort-predict, cohort-pharos, predict-pharos),
                          event (the names of outcome events), theta (names for all components to be estimated), zz (the labels of the nonfunctional covariates Z), xx (the labels of the functional covariates X),
                          val (all estimated values for theta: "est", "varest", "varlo", "varhi", "boot_varest", "boot_varlo",
                          "boot_varhi") and the flatten time points.}
         \item{Ftest.store}{array of values for the estimated monotone marginal distributions \eqn{F_{es}(t|X, Z)} (\code{Ftest} in the \code{\link{gamm4.estimates}} function
                            and \code{Ft.var.boot} in the \code{\link{boot.compare.studies}} function) at each iteration. See the argument \code{null.theta.simus.est.ciboot} in the \code{\link{all_null_theta}} function
                            for the dimensions of the array.}
         \item{eflag}{an integer number to check if any error comes up while processing the estimation algorithm.
                      If this value is -1, then the marginal distribution \eqn{F_{es}(t|X, Z)} has missing values (NA).}
}
\description{
This function is to call and run JPRAT algorithm.
}
\details{
The Joint Progression of Risk Assessment Tool (JPRAT) evaluates and compares all outcomes simultaneously
         across multiple studies and adjusts for outcome dependencies.
         The function \code{\link{jprat.wrapper}} is an estimation procedure that handles multiple data hierarchy
         using an additive logistic mixed effect model. The algorithm handles censoring with pseudo-values and
         functional covariate effects with splines.
         The description for the detailed estimation procedure is in the following paper:
         Garcia, T. P., Marder, K., Wang, Y. (2017). Time-varying proportional odds model for mega-analysis of clustered event
         times. Biostatistics, 20(1), 129-146.
         For the real data analysis, details are in the following clinical paper:
         Garcia, T.P., Wang, Y., Shoulson, I., Paulsen, J.S. and Marder, K. (2018). Disease progression in Huntington disease:
         An analysis of multiple longitudinal outcomes. Journal of Huntington's disease, 7, 337-344
}
\examples{

####################################
# For JPRAT estimation: Input data #
####################################
study.names=c("cohort", "predict", "pharos");
input.data.list=list(cohort=data_cohort, predict=data_predict, pharos=data_pharos);
nonfunctional.covariate.names=c("base_age");
functional.covariate.names="CAG";
othercovariate.names=c("firstyear", "lastyear");
event.outcome.names=c("hdage_nobase", "mcione", "tfctwo");
delta.names=c("delta.hdage_nobase", "delta.mcione", "delta.tfctwo");
time.points.for.prediction=seq(46, 66, by=5)
time.points.for.conditional.prediction=c(46, 51, 56);
time.points.for.conditional.prediction.toadd=c(5);
nonfunctional.covariate.value=c(40);
functional.covariate.values.of.interest=c(46, 48, 50) ;

#######################################
# How to analysis in JPRAT estimation #
#######################################
number.of.bootstraps=100;
use.functional.beta.intercept= TRUE ;
use.functional.event.coefficients= TRUE;
use.functional.study.coefficients=TRUE;
check.study.equality=FALSE;
what.analyzed.separately="studyevent";
estimated.parameters.common.for.all.studies=FALSE;
use.bootstrap.variance=TRUE ;
estimation.when.censoring.depends.on.z=FALSE ;
estimate.variances="est";
write.output=TRUE;



jprat.estimate.results<-jprat.wrapper(study.names=study.names,
  input.data.list=input.data.list,
  nonfunctional.covariate.names=nonfunctional.covariate.names,
  functional.covariate.names=functional.covariate.names,
  othercovariate.names=othercovariate.names,
  event.outcome.names=event.outcome.names,
  delta.names=delta.names,
  time.points.for.prediction=time.points.for.prediction,
  time.points.for.conditional.prediction=time.points.for.conditional.prediction,
  time.points.for.conditional.prediction.toadd=time.points.for.conditional.prediction.toadd,
  nonfunctional.covariate.value=nonfunctional.covariate.value,
  functional.covariate.values.of.interest=functional.covariate.values.of.interest,
  number.of.bootstraps=number.of.bootstraps,
  use.functional.beta.intercept=use.functional.beta.intercept,
  use.functional.event.coefficients=use.functional.event.coefficients,
  use.functional.study.coefficients=use.functional.study.coefficients,
  check.study.equality=check.study.equality,
  estimated.parameters.common.for.all.studies=estimated.parameters.common.for.all.studies,
  what.analyzed.separately=what.analyzed.separately,
  estimation.when.censoring.depends.on.z=estimation.when.censoring.depends.on.z,
  use.bootstrap.variance=use.bootstrap.variance,
  estimate.variances=estimate.variances,
  write.output=write.output)

}
